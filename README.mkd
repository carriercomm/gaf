# gaf -- gitify arbitrary files

Normally, the git work tree has to be within a given directory; you can't
manage arbitrary files using git.  Gaf allows you to do what it says on the
tin -- gitify arbitrary files.  It does this by **copying** files between the
**current directory** and the **gaf repo**.

I use gaf for dotfile management, and maintaining /etc, /var/named, etc.
(which are kind of like system-level dotfiles anyway).  Once things are setup
and stable, except for adding new files the only command I run regularly is
`gaf cycle && gaf push`.

Also, remember the gaf repo is just a normal git repo, so you can "cd" there
and do whatever you want.

(I also use it to save copies of arbitrary files "just in case"; see the last
section for details).

## gaf commands

*   **`gaf init`** -- creates the repo (`~/.gaf` by default, or wherever the
    env var `GAF_REPO` points to).

        git init

*   **`gaf save`**

    *   `gaf save <branch> <paths>` -- copies given files and directories to
        the repo and commits them on the given branch name.  The branch will
        be created if needed.

            gaf save base .bashrc .gitconfig .less .vimrc .vim
            gaf save personal .muttrc* .taskrc .ssh .gnupg
            gaf save scripts  bin

    *   `gaf save <branch>` -- with just a branch name, recopies and
        commits files **already known** to the branch (think "git add -u"
        here).

            gaf save base

    *   `gaf save` (with no arguments) is a shortcut for running `gaf save
        <branch>` for each branch in the **feature list**.

            gaf save

    <font color="red">**WARNING**</font>: `gaf save` does not deal with
    deleted files.  You will have to "cd" to the gaf repo directory and fix it
    yourself.  This may change later, if people ask!

    Any branch you save is added to the **feature list**, which is just a
    plain text file at `~/.gaf.flist` by default.

*   **`gaf restore`**

    *   `gaf restore <branch>` -- copies files from branch to current
        directory.

            gaf restore base
            gaf restore scripts

    *   `gaf restore` (with no arguments) is a shortcut for running `gaf
        restore <branch>` for each branch in the feature list.

    Any branch you restore is also added to the **feature list**.

    **TIP**: dry-running the restore is easy; just run it within an empty
    directory to see what files would get written.

*   **`gaf list`** -- like "git branch" but branches that are in the feature
    list are marked with an asterisk.

*   **`gaf cycle`** -- does one complete cycle of a typical commit-then-merge
    development loop.  For each branch in the feature list, it runs:

    *   `gaf save <branch>` to save your local changes
    *   `gaf pull` to fetch and merge changes from the central server
    *   `gaf restore <branch>` to copy the (merged) files to your current
        directory

    **`gaf pull` may fail** due to merge conflicts, in which case the entire
    'cycle' operation will abort; you should "cd" to the gaf repo, fix the
    conflict, commit, and then rerun the `gaf cycle` command.

    **WARNING**: cycle won't run if you're not in your $HOME.  At present
    there's no getting around this; ask me if you need to.

*   **`gaf find`**

    *   `gaf find <pattern>`: uses "egrep -i" on the *names* of the files
        (not contents!) in all branches and prints the results.

    *   `gaf find <pattern> <branches>`: same, but only in given branches.

*   **`gaf diff`**

    *   `gaf diff`: prints branch information then runs `git diff --stat`
        for each branch in the feature list.  Note this involves checking out
        each branch in turn!

    *   `gaf diff <branch> [<diff options>]`: runs a full diff for the
        given branch.  You can append whatever options you like; the default
        is nothing so you get a plain `git diff`.

    Use this to see what changes `gaf save` would commit.  Or conversely, what
    changes `gaf restore` would overwrite!

    This is the only command that usurps a git command name.  If you have an
    alias for diff in your `~/.gitconfig` you can still use that as normal of
    course.

*   **`gaf untracked`**

    Run this from whatever directory was the base for the files saved to gaf
    (usually $HOME).  It's a little inefficient but not noticeably so.  Useful
    to review the files you're *not* saving, and consider if some of them
    should be saved to some feature.

*   **`gaf <any git command or alias + args>`** 

    You probably wondered how `gaf pull` would work, since we didn't list that
    as a "gaf command".  It works because gaf takes anything that it does not
    recognise and runs it via *git* itself, after `cd`-ing to the gaf repo.

The rest of it is plain git -- like creating a bare server repo, pushing to
it, cloning from it on another machine (**don't forget** to clone it as
`~/.gaf`!!), etc. -- except that you don't have to do everything *from the gaf
repo*.  For example, this is how the first machine would set up the "remote
server":

    gaf remote add origin <URL>
    gaf push origin -u --all

## managing /etc and such

If you cd to "/" and set GAF\_REPO to some non-default location, gaf behaves a
bit like etckeeper, with two important plus points (in my view):

*   It doesn't unconditionally commit the whole `/etc` every night!
*   It lets me add stuff outside `/etc` as well, like /var/named/...,
    /var/spool/cron, etc.

The downside is permissions.  At the moment gaf does not deal with permissions
in any way, so all the files it handles are written back to disk with
permissions determined by the 'git archive' command.  At the moment I do this:

*   run `git config tar.umask = 0022` in the gaf repo.  The default is 0002,
    believe it or not!
*   after a 'restore' or 'cycle', I run a custom script with some hardcoded
    path names that need to be "chmod go-rx"-ed.

## saving arbitrary work-in-progress

I use this for stuff like documents, spreadsheets, etc.; basically anything
that is of short term value (less than a year, say), and doesn't belong to any
specific project, but which you still want to checkpoint for safety while
working on it.  I have a shell function called "save":

    save() (
        export GAF_REPO=$HOME/.save
        [ -d $GAF_REPO ] || gaf init
        gaf save `date +%Y-%m`-save "$@"
    )

so I just run, for example, `save review-comments.odt`.

Note how we use a different gaf repo than the default, and how the function
runs in a subshell to avoid setting that variable in the current shell.  Also
note how the branch names are created to start with YY-MM for easy disposal.
Finally, note that this kind of branch is not -- generally -- a suitable
candidate for "restore" (which is why it's in a non-default gaf repo!)
